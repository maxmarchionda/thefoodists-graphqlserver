"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var graphql_extensions_1 = require("graphql-extensions");
var apollo_tracing_1 = require("apollo-tracing");
var apollo_cache_control_1 = require("apollo-cache-control");
var errors_1 = require("./errors");
var logging_1 = require("./logging");
function isQueryOperation(query, operationName) {
    var operationAST = graphql_1.getOperationAST(query, operationName);
    return operationAST.operation === 'query';
}
function runQuery(options) {
    return Promise.resolve().then(function () { return doRunQuery(options); });
}
exports.runQuery = runQuery;
function doRunQuery(options) {
    if (options.queryString && options.parsedQuery) {
        throw new Error('Only supply one of queryString and parsedQuery');
    }
    if (!(options.queryString || options.parsedQuery)) {
        throw new Error('Must supply one of queryString and parsedQuery');
    }
    var debugDefault = process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test';
    var debug = options.debug !== undefined ? options.debug : debugDefault;
    var context = options.context || {};
    var extensions = options.extensions ? options.extensions.map(function (f) { return f(); }) : [];
    if (options.tracing) {
        extensions.push(new apollo_tracing_1.TracingExtension());
    }
    if (options.cacheControl === true) {
        extensions.push(new apollo_cache_control_1.CacheControlExtension());
    }
    else if (options.cacheControl) {
        extensions.push(new apollo_cache_control_1.CacheControlExtension(options.cacheControl));
    }
    if (options.logFunction) {
        extensions.push(new logging_1.LogFunctionExtension(options.logFunction));
    }
    var extensionStack = new graphql_extensions_1.GraphQLExtensionStack(extensions);
    if (extensions.length > 0) {
        graphql_extensions_1.enableGraphQLExtensions(options.schema);
    }
    context._extensionStack = extensionStack;
    var requestDidEnd = extensionStack.requestDidStart({
        request: options.request,
        queryString: options.queryString,
        parsedQuery: options.parsedQuery,
        operationName: options.operationName,
        variables: options.variables,
    });
    return Promise.resolve()
        .then(function () {
        var documentAST;
        if (options.parsedQuery) {
            documentAST = options.parsedQuery;
        }
        else if (!options.queryString) {
            throw new Error('Must supply one of queryString and parsedQuery');
        }
        else {
            var parsingDidEnd = extensionStack.parsingDidStart({
                queryString: options.queryString,
            });
            var graphqlParseErrors = void 0;
            try {
                documentAST = graphql_1.parse(options.queryString);
            }
            catch (syntaxError) {
                graphqlParseErrors = errors_1.formatApolloErrors([
                    errors_1.fromGraphQLError(syntaxError, {
                        errorClass: errors_1.SyntaxError,
                    }),
                ], {
                    formatter: options.formatError,
                    debug: debug,
                });
            }
            finally {
                parsingDidEnd.apply(void 0, (graphqlParseErrors || []));
                if (graphqlParseErrors) {
                    return Promise.resolve({ errors: graphqlParseErrors });
                }
            }
        }
        if (options.nonQueryError &&
            !isQueryOperation(documentAST, options.operationName)) {
            throw options.nonQueryError;
        }
        var rules = graphql_1.specifiedRules;
        if (options.validationRules) {
            rules = rules.concat(options.validationRules);
        }
        var validationDidEnd = extensionStack.validationDidStart();
        var validationErrors;
        try {
            validationErrors = graphql_1.validate(options.schema, documentAST, rules);
        }
        catch (validationThrewError) {
            validationErrors = [validationThrewError];
        }
        finally {
            try {
                if (validationErrors) {
                    validationErrors = errors_1.formatApolloErrors(validationErrors.map(function (err) {
                        return errors_1.fromGraphQLError(err, { errorClass: errors_1.ValidationError });
                    }), {
                        formatter: options.formatError,
                        logFunction: options.logFunction,
                        debug: debug,
                    });
                }
            }
            finally {
                validationDidEnd.apply(void 0, (validationErrors || []));
                if (validationErrors && validationErrors.length) {
                    return Promise.resolve({
                        errors: validationErrors,
                    });
                }
            }
        }
        var executionArgs = {
            schema: options.schema,
            document: documentAST,
            rootValue: options.rootValue,
            contextValue: context,
            variableValues: options.variables,
            operationName: options.operationName,
            fieldResolver: options.fieldResolver,
        };
        var executionDidEnd = extensionStack.executionDidStart({
            executionArgs: executionArgs,
        });
        return Promise.resolve()
            .then(function () { return graphql_1.execute(executionArgs); })
            .catch(function (executionError) {
            return {
                errors: [errors_1.fromGraphQLError(executionError)],
            };
        })
            .then(function (result) {
            var response = {
                data: result.data,
            };
            if (result.errors) {
                response.errors = errors_1.formatApolloErrors(result.errors.slice(), {
                    formatter: options.formatError,
                    logFunction: options.logFunction,
                    debug: debug,
                });
            }
            executionDidEnd.apply(void 0, result.errors);
            var formattedExtensions = extensionStack.format();
            if (Object.keys(formattedExtensions).length > 0) {
                response.extensions = formattedExtensions;
            }
            if (options.formatResponse) {
                response = options.formatResponse(response, options);
            }
            return response;
        });
    })
        .catch(function (err) {
        requestDidEnd(err);
        throw err;
    })
        .then(function (graphqlResponse) {
        extensionStack.willSendResponse({ graphqlResponse: graphqlResponse });
        requestDidEnd();
        return graphqlResponse;
    });
}
//# sourceMappingURL=runQuery.js.map